import uuid
from datetime import datetime, timezone
from typing import Annotated, Literal
from pydantic import BaseModel, Field
from protocols_io_mcp.server import mcp
import protocols_io_mcp.utils.helpers as helpers

class User(BaseModel):
    username: Annotated[str, Field(description="Unique identifier for the user")]
    name: str
    affiliation: Annotated[str | None, Field(description="Affiliation of the user, if the user is not affiliated, this will be null")] = None

    @classmethod
    def from_api_response(cls, data: dict) -> "User":
        return cls(
            username=data["username"],
            name=data["name"],
            affiliation=data["affiliation"] or None
        )

class ProtocolStep(BaseModel):
    id: Annotated[str, Field(description="Unique identifier for the protocol step, must be generated by generate_ids if creating a new step")]
    previous_id: Annotated[str | None, Field(description="ID of the previous step, only the first step can have a null previous_id")] = None
    description: str
    section: Annotated[str | None, Field(description="Section of the protocol step, this should typically not be null to maintain protocol structure clarity, but can be null under speicial circumstances")] = None
    section_color: Annotated[str | None, Field(description="Color of the section represented by the hex color code, if the section is not colored, this will be null")] = None
    is_substep: Annotated[bool, Field(description="Whether the protocol step is a substep or not. If true, this step will become a substep of the most recent main step in the protocol. If false, this step will be a main step in the protocol")]

    @classmethod
    def from_api_response(cls, data: dict) -> "ProtocolStep":
        return cls(
            id=data.get("guid"),
            previous_id=data.get("previous_guid") or None,
            description=data.get("step"),
            section=data.get("section") or None,
            section_color=data.get("section_color") or None,
            is_substep=data.get("is_substep") or False,
        )

class Protocol(BaseModel):
    id: Annotated[int, Field(description="Unique identifier for the protocol")]
    title: str
    description: Annotated[str | None, Field(description="Description of the protocol, if the protocol does not have a description, this will be null")] = None
    guidelines: Annotated[str | None, Field(description="Guidelines for the protocol, if the protocol does not have guidelines, this will be null")] = None
    before_start: Annotated[str | None, Field(description="Text to be displayed before the start of the protocol, if the protocol does not have this text, this will be null")] = None
    warning: Annotated[str | None, Field(description="Warning text for the protocol, if the protocol does not have a warning, this will be null")] = None
    materials_text: Annotated[str | None, Field(description="Text describing the materials used in the protocol, if the protocol does not have this text, this will be null")] = None
    public: bool
    doi: Annotated[str | None, Field(description="DOI of the protocol, if the protocol is not published, this will be null")] = None
    url: str
    creator: User
    authors: list[User]
    protocol_references: Annotated[str | None, Field(description="References cited in the protocol, if the protocol does not have references, this will be null")] = None
    created_on: datetime
    published_on: Annotated[datetime | None, Field(description="Date and time the protocol was published, if the protocol is private, this will be null")] = None

    @classmethod
    async def from_api_response(cls, data: dict) -> "Protocol":
        response_additional = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{data['id']}")
        if response_additional["status_code"] != 0:
            protocol_references = None
        else:
            protocol_references = response_additional["payload"].get("protocol_references") or None

        return cls(
            id=data["id"],
            title=data["title"],
            description=data.get("description") or None,
            guidelines=data.get("guidelines") or None,
            before_start=data.get("before_start") or None,
            warning=data.get("warning") or None,
            materials_text=data.get("materials_text") or None,
            doi=data.get("doi") or None,
            public=data["public"],
            url=data["url"],
            creator=User.from_api_response(data["creator"]),
            authors=[User.from_api_response(author) for author in data["authors"]],
            protocol_references=protocol_references,
            created_on=datetime.fromtimestamp(data.get("created_on"), tz=timezone.utc),
            published_on=datetime.fromtimestamp(data.get("published_on"), tz=timezone.utc) if data.get("published_on") else None,
        )

class ErrorResponse(BaseModel):
    error_message: str

    @classmethod
    def from_api_response(cls, data: str) -> "ErrorResponse":
        return cls(
            error_message=data
        )

@mcp.tool()
async def create_blank_protocol() -> Protocol | ErrorResponse:
    """Create a blank new protocol on protocols.io."""
    data = {
        "type_id": 1,
    }
    response = await helpers.access_protocols_io_resource("POST", f"/v3/protocols/{uuid.uuid4().hex}", data)
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["error_message"])
    protocol = await Protocol.from_api_response(response["protocol"])
    return protocol

@mcp.tool()
async def get_protocol(protocol_id: int) -> Protocol | ErrorResponse:
    """Get the protocol with the specified ID from protocols.io."""
    response = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{protocol_id}")
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["status_text"])
    protocol = await Protocol.from_api_response(response["payload"])
    return protocol

@mcp.tool()
async def get_protocol_steps(protocol_id: int) -> list[ProtocolStep] | ErrorResponse:
    """Get the steps of the protocol with the specified ID from protocols.io."""
    response = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{protocol_id}/steps")
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["status_text"])
    steps = [ProtocolStep.from_api_response(step) for step in response.get("payload", [])]
    return steps

@mcp.tool()
async def get_user_protocol_list() -> list[Protocol] | ErrorResponse:
    """Get a list of all protocols on protocols.io."""
    response_profile = await helpers.access_protocols_io_resource("GET", f"/v3/session/profile", {})
    if response_profile["status_code"] != 0:
        return ErrorResponse.from_api_response(response_profile["error_message"])
    response = await helpers.access_protocols_io_resource("GET", f"/v3/researchers/{response_profile['user']['username']}/protocols?filter=user_all")
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["error_message"])
    protocols = [await Protocol.from_api_response(protocol) for protocol in response.get("items")]
    return protocols

@mcp.tool()
async def get_public_protocol_list_by_keyword(protocol_filter: Literal["public", "user_public", "user_private", "shared_with_user"], keyword: str, page_size: int = 10, page_id: int = 1) -> list[Protocol] | ErrorResponse:
    """Get a list of public protocols on protocols.io by keyword."""
    response = await helpers.access_protocols_io_resource("GET", f"/v3/protocols?filter={protocol_filter}&key={keyword}&page_size={page_size}&page_id={page_id}")
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["error_message"])
    protocols = [await Protocol.from_api_response(protocol) for protocol in response.get("items", [])]
    return protocols

@mcp.tool()
async def update_protocol(
    protocol_id: int,
    title: str | None = None,
    description: str | None = None,
    guidelines: str | None = None,
    before_start: str | None = None,
    warning: str | None = None,
    materials_text: str | None = None,
    protocol_references: Annotated[str | None, Field(description="References cited in the protocol in the format '[1] title, DOI\n[2] title, DOI\n...' where each reference includes title and DOI, numbered sequentially and separated by \n")] = None,
) -> Protocol | ErrorResponse:
    """Update the specific protocol on protocols.io, if the field is not provided, it will not be updated."""
    data = {}
    if title is not None:
        data["title"] = title
    if description is not None:
        data["description"] = description
    if guidelines is not None:
        data["guidelines"] = guidelines
    if before_start is not None:
        data["before_start"] = before_start
    if warning is not None:
        data["warning"] = warning
    if materials_text is not None:
        data["materials_text"] = materials_text
    if protocol_references is not None:
        data["protocol_references"] = protocol_references
    if not data:
        return ErrorResponse(error_message="No fields to update provided. Please provide at least one field to update.")
    response = await helpers.access_protocols_io_resource("PUT", f"/v4/protocols/{protocol_id}", data)
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["status_text"])
    protocol_response = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{protocol_id}")
    if protocol_response["status_code"] != 0:
        return ErrorResponse.from_api_response(protocol_response["status_text"])
    protocol = await Protocol.from_api_response(protocol_response["payload"])
    return protocol

@mcp.tool()
async def create_or_update_protocol_step(protocol_id: int, steps: list[ProtocolStep]) -> Protocol | ErrorResponse:
    """Create or update the steps of a protocol on protocols.io, if the step already exists (identified by its ID), it will be updated, otherwise it will be created."""
    steps_data = []
    for step in steps:
        step_data = {
            "guid": step.id,
            "previous_guid": step.previous_id,
            "step": step.description,
            "section": step.section,
            "section_color": step.section_color,
            "is_substep": step.is_substep
        }
        steps_data.append(step_data)
    data = {
        "steps": steps_data
    }
    response = await helpers.access_protocols_io_resource("POST", f"/v4/protocols/{protocol_id}/steps", data)
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["status_text"])
    protocol_response = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{protocol_id}")
    if protocol_response["status_code"] != 0:
        return ErrorResponse.from_api_response(protocol_response["status_text"])
    protocol = await Protocol.from_api_response(protocol_response["payload"])
    return protocol

@mcp.tool()
async def delete_protocol_step(protocol_id: int, step_ids: list[str]) -> Protocol | ErrorResponse:
    """Delete steps from a protocol on protocols.io."""
    data = {
        "steps": step_ids
    }
    response = await helpers.access_protocols_io_resource("DELETE", f"/v4/protocols/{protocol_id}/steps", data)
    if response["status_code"] != 0:
        return ErrorResponse.from_api_response(response["status_text"])
    protocol_response = await helpers.access_protocols_io_resource("GET", f"/v4/protocols/{protocol_id}")
    if protocol_response["status_code"] != 0:
        return ErrorResponse.from_api_response(protocol_response["status_text"])
    protocol = await Protocol.from_api_response(protocol_response["payload"])
    return protocol